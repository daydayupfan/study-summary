1、什么是死锁（dead Lock）?
两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。
t1等待t2线程执行结束进行之后的操作，同样t2也在等待t1执行结束。 

2、产生死锁的四个必要条件
互斥条件：一个资源每次只能被一个进程使用。
保持和请求条件：一个进程因请求资源而阻塞时，对已获得资源保持不放。
不可剥夺性：进程已获得资源，在未使用完成前，不能被剥夺。
循环等待条件（闭环）：若干进程之间形成一种头尾相接的循环等待资源关系。

3、Synchronized实现原理
使用工具查看class文件编译成的汇编指令可知晓，其实现使用了监控器锁（monitor）进行实现
monitorenter：当monitor计数为0时，计数+1获得所有权，若同一线程多次操作将累加计数，其他线程查看计数！=0将进行阻塞等待资源释放;
monitorexit:当计数累减为0时进行资源释放，其他阻塞线程就可尝试获取所有权；
同步方法使用的是常量池标志ACC_SYNCHRONIZED.

4、wait、notify、notifyAll
wait: 会释放锁
notify: 唤醒线程但不释放锁
notifyAll: 唤醒所有线程

5、内存屏障
Store：将处理器缓存的数据刷新到内存中。
Load：将内存存储的数据拷贝到处理器的缓存中。
LoadLoad:该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作
StoreStore:该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作
LoadStore:确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作
StoreLoad:该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。
它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令。