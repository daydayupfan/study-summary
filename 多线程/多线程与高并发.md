

```
设定线程数= cpu内核数*cpu使用率*（1+W/C）
W:等待时间 C:运行时间
```

并发编程三大特性： 原子性、可见性、有序性





缓存行 64字节  缓存一致性协议

单线程是使用的最终一致性，参数之间没有依赖关系的情况是允许volatile禁止指令重排
可以解决这个指令乱序的问题,volatile也采用了缓存一致性协议（线程会对堆中共享空间的参数复制一个副本，
副本与副本之间数据没来得及同步就造成了线程安全问题），4保证了可见与有序性，但保证不了原子性

this对象溢出  初始化和指针赋值可能会互换顺序



程序出现异常 锁会被释放

锁升级 偏向锁 自旋锁（线程数少 执行时间短 cpu） 重量级锁（线程数多 执行时间长 OS）



CAS(compare and swap set(java11)) 乐观锁

cpu级别的原语操作，不能被打断，要么成功要么失败



ABA 数据中间经历了变化又改为原值，还是执行成功了

```
线程1：1->2
线程2：1->2->1
线程1：1->2 成功 
避免 操作时加上时间戳（版本号）
```

UnSafe 相当于 c++中的指针 1.8之后已经禁用外部直接调用了

countDownLatch、CyclicBarrier、LongAdder、

Phaser（不同线程不同执行流程、结果）、

Semaphore（信号量：限流）允许多少个线程同时执行买 例：票窗口

Exchanger:两个线程之间互换数据

LockSupport



独占 共享 排他

java对象引用  强软弱虚

软 内存够用就不会被gc (可做缓存)

虚引用用不到，获取不到值 为空就在队列中添加数据（jvm层使用）



ThreadPoolExecutor 

ForkJoinPool:线程中的任务队列 会采用并行方式进行执行 效率较高



disruptor :

```
单机最快的MQ  
逻辑环形结构  
会直接覆盖数据（8种覆盖策略）初始化的时候直接会使用EventFactory分配内存等到数据来的时候直接进行赋值（替换）降低GC频率 
队列大小必须设置为 2的幂次方

```



