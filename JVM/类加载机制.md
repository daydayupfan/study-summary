##一、类加载过程
1、加载（loading）
  双亲委派：
2、链接（linking）
```
检验（Verification）：验证文件是否符合JVM规定 cafe beby
准备（Preparation）：静态成员变量赋默认值
解析（Resolution）：将类、方法、属性等符号引用解析为直接引用
常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用
```
3、初始化（initializing）：调用类初始化代码 <clinit>，给静态成员变量赋初始值

##二、类加载器
```
BootstrapClassLoader（启动类加载器）:
c++编写，加载java核心库 java.*,构造ExtClassLoader和AppClassLoader。
由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作
ExtClassLoader （标准扩展类加载器）:
java编写，加载扩展库，如classpath中的jre ，javax.*或者 java.ext.dir 指定位置中的类，开发者可以直接使用标准扩展类加载器。
主要负责加载jre/lib/ext目录下的一些扩展的jar
AppClassLoader（系统类加载器）:java编写，加载程序所在的目录，如user.dir所在的位置的class
CustomClassLoader（用户自定义类加载器）:java编写,用户自定义的类加载器,可加载指定路径的class文件
```
##三、什么是双亲委派
寻找Class 总会先去询问父类加载器，父类没有将会一直向上询问直到询问bootstrapClassLoader,bootstrapClassLoader也没有将会向下询问子类
加载器是否能加载，直到询问到自定义加载器，若是都不能加载抛出ClassNotFoundException.

![双亲委派](E:\ideaWorkSpace2019\study\study-summary\JVM\images\双亲委派.png)

















