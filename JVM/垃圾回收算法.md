## 一、垃圾确定算法

```
根可达性算法：根据GC root对象向下搜索，搜索过路径称为的引用链，在GC root对象没有任何引用相连时对象成为垃圾 可被回收
引用计数：对象之间存在引用，引用计数会进行+1，当引用失效计数-1，计数=0时，表示对象为垃圾可被回收（存在对象循环引用，垃圾无法回收的情况）
```

## 二、方法区

1.7之前的版本叫做永久代，1.8之后被称为metaspace(大小取决于内存空间),都是方法区不同的实现；
1.8之后已经移除了永久代，并且字符串常量池与类静态变量并入了堆中;
不使用永久代最要是回收效率偏低，增加了复杂度，容易出现OOM的情况。

## 三、新生代、老年代、永久代结构

1、新生代（Young GC） eden survivor FROM、survivor TO ,比例默认8：1：1，   默认占堆的三分之一

2、老年代(Old Generation) 
3、永久代（permanent generation) 1.8已经移除，使用metaspace(元空间)替代；

```
minor GC:使用复制算法，又称为 年轻代GC
major GC：发生在老年代 又称Full GC，效率比minorGC 至少慢10倍
```

```
老年代中存活对象多，不适用复制算法，使用标记-整理（压缩）算法；
minorGC之后 存活对象内存大于 survivor 也大于老年代剩余空间 会触发FULL GC；

```



![](E:\ideaWorkSpace2019\study\study-summary\JVM\images\年轻代 老年代 永久代.png)



## 四、垃圾回收算法

**1.Mark-Sweep（标记-清除）算法**：实现简单，但会产生大量内存碎片，若之后为大对象开辟空间不成功会再次触发垃圾收集.

![](E:\ideaWorkSpace2019\study\study-summary\JVM\images\标记-清除算法.png)

**2.Copying（复制）算法**：运行高效，不容易产生内存碎片，但空间成本高,随着成活对象的增多，效率会降低.

![](E:\ideaWorkSpace2019\study\study-summary\JVM\images\复制算法.png)

**3.Mark-Compact（标记-整理）算法（压缩法）**：标记阶段和1一致，但在清除之前会将存活对象都向一端移动，之后整体进行清除边界数据，空间利用率高.

![](E:\ideaWorkSpace2019\study\study-summary\JVM\images\标记-整理算法.png)

## 五、存活对象何时进入老年代

```
1、分代年龄到达15
2、大对象直接进入
3、存活对象大小大于 survivor50%大小
```

## 六、常见垃圾回收器

```
1.Serial/Serial Old收集器 是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是Copying算法，Serial Old收集器是针对老年代的收集器，采用的是Mark-Compact算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。

2.ParNew收集器 是Serial收集器的多线程版本，使用多个线程进行垃圾收集。

3.Parallel Scavenge收集器 是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。

4.Parallel Old收集器 是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。

5.CMS（Concurrent Mark Sweep）收集器 是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。

6.G1收集器 是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。动态调整老年新生代大小 （三色标记+SATB）
```

## 七、CMS 垃圾回收器

1.初始标记：STW，只标记GC Roots能直接关联到的对象。
2.并发标记：GC Roots Tracing
3.重新标记：STW，修正并发标记期间，因用户程序继续运行导致标记产生变动的那一部分对象的标记记录。
4.并发清除：并发清除可以和用户线程一起运行，所以总体上停顿的时间非常短。

![](E:\ideaWorkSpace2019\study\study-summary\JVM\images\并发标记过程.png)

缺点：

```
1.对CPU资源敏感。
2.无法处理浮动垃圾。(并发清理时刻产生)
3.收集结束后会产生大量碎片。(标记-清除 mark-sweep)
```

https://www.jianshu.com/p/5116a7acb866 三色标记全解