1、MYISAM 非聚簇索引 索引和数据不在一个文件 MYI MYD,INNODB聚簇索引索引和文件在ibd文件中；
2、主键使用自增int类型优势在于 顺序IO 占用空间小 主键之间比较成本低
3、INNODB 索引使用中使用B+Tree 可支持千万级别的数据查询（16K*3层 第一二层 主键+指针=14bit 约等于10^6乘以10 ）
4、聚合索引(name,age)在sql查询时如果打乱了查询条件where age =10 ,name ='张三'会不走索引，原因在于B+Tree(第三层)数据都是按照
索引创建时name,age 存放的顺序io 打乱顺序会导致索引不生效。
5、MYSQL binlong 两种日志录入格式以及区别

```
Statement：每一条会修改数据的sql都会记录在binlog中。
优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。
缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同的结果。

Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。
优点：binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。
缺点：所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。
```

## 索引失效的条件

```
不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描；
存储引擎不能使用索引范围条件右边的列;
尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *;
mysql在使用不等于（！=或者<>）的时候无法使用索引会导致全表扫描;
is null,is not null也无法使用索引;
like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。
```

## 索引优化原则

```
1.选择唯一性索引;
2.为经常需要排序、分组和联合操作的字段建立索引;
3.为常作为查询条件的字段建立索引;
4.限制索引的数目;
5.尽量使用数据量少的索引;
6.尽量使用前缀来索引
7.删除不再使用或者很少使用的索引
8.最左前缀匹配原则，非常重要的原则。
mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a 1=”” and=”” b=”2” c=”“> 3 and d = 4 
如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
9.=和in可以乱序。
10.尽量选择区分度高的列作为索引。
区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少.
11.索引列不能参与计算，保持列“干净”。
12.尽量的扩展索引，不要新建索引。
```

## MYISAM与INNODB引擎下select count(*)哪个更快，为什么？
MYISAM更快，以为总行数直接是存放在磁盘的，count（*）直接读取返回就可以了；

INNODB是不会记下总行数的，需要查询每行数据进行累加得出。



## MySQL索引是如何提高查询效率的呢？
涉及到B+树的设计原理，尽量减少IO访问

INNODB 引擎页大小为64KB，深度为3的情况可支持10^9 10亿数据量的查询
![](E:\ideaWorkSpace2019\study\study-summary\数据库\mysql\images\B+树结构.jpg)



INNODB 事务隔离级别

### SQL标准中的事务四种隔离级别
| 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| ---------------------------- | ------------------ | -------------------------------- | -------------------- |
| 未提交读（Read uncommitted） | 可能               | 可能                             | 可能                 |
| 已提交读（Read committed）   | 不可能             | 可能                             | 可能                 |
| 可重复读（Repeatable read）  | 不可能             | 不可能                           | 可能                 |
| 可串行化（Serializable ）    | 不可能             | 不可能                           | 不可能               |

- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
  数据库一般都不会用，而且任何操作都不会加锁
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
  在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。
  在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
- 串行读(Serializable)：读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差.


###脏读、不可重复读、幻读的区别
脏读：一个事务修改数据还未提交，另一个事务读取了未提交数据，并进行了使用；
不可重复度：一个事务中多次读取同一数据，另一个事务对数据进行了修改，造成多次读取数据不一致；
幻读：一个事务批量处理数据时，另一个事务插入或删除数据，检验结果时发现还有未处理数据或者数据少了。










