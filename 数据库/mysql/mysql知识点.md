1、MYISAM 非聚簇索引 索引和数据不在一个文件 MYI MYD,INNODB聚簇索引索引和文件在ibd文件中；
2、主键使用自增int类型优势在于 顺序IO 占用空间小 主键之间比较成本低
3、INNODB 索引使用中使用B+Tree 可支持千万级别的数据查询（16K*3层 第一二层 主键+指针=14bit 约等于10^6乘以10 ）
4、聚合索引(name,age)在sql查询时如果打乱了查询条件where age =10 ,name ='张三'会不走索引，原因在于B+Tree(第三层)数据都是按照
索引创建时name,age 存放的顺序io 打乱顺序会导致索引不生效。
5、MYSQL binlong 两种日志录入格式以及区别

```
Statement：每一条会修改数据的sql都会记录在binlog中。
优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。
缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在slave得到和在master端执行时候相同的结果。

Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改。
优点：binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。
缺点：所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容。
```

##索引失效的条件
```
不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描；
存储引擎不能使用索引范围条件右边的列;
尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select *;
mysql在使用不等于（！=或者<>）的时候无法使用索引会导致全表扫描;
is null,is not null也无法使用索引;
like以通配符开头（’%abc…’）mysql索引失效会变成全表扫描的操作。
```

##索引优化原则
```
1.选择唯一性索引;
2.为经常需要排序、分组和联合操作的字段建立索引;
3.为常作为查询条件的字段建立索引;
4.限制索引的数目;
5.尽量使用数据量少的索引;
6.尽量使用前缀来索引
7.删除不再使用或者很少使用的索引
8.最左前缀匹配原则，非常重要的原则。
mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a 1=”” and=”” b=”2” c=”“> 3 and d = 4 
如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
9.=和in可以乱序。
10.尽量选择区分度高的列作为索引。
区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少.
11.索引列不能参与计算，保持列“干净”。
12.尽量的扩展索引，不要新建索引。
```